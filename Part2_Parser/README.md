Let's build a Parser now.

<h2>What is a Parser?</h2>

A parser is a crucial component responsible for analyzing the structure of the source code. The parser takes the output generated by the lexical analyzer (also known as a lexer) and organizes it into a format that can be further processed by the compiler.

<i>This is the GPT Definition</i>

<h3>My Definition goes like:</h3>

Let's use our previous example the identified data from the lexer we get from the translator is now traversed and parser recognizes the syntax and structural elements of the input and ensure that they conform to the <i>syntax</i> of the language.

Well we can already handled then four basic math operations and the whole numbers.

<h2>BNF: Backus-Naur Form</h2>

Backus Naur Form or BNF is a formal method for describing the syntax of programming language.

Let's express maths expressions wit whole numbers. Here is the BNF description of the grammar:

```bash

expression: number
          | expression '*' expression
          | expression '+' expression
          | expression '-' expression
          | expression '/' expression
          ;

number : T_INTLIT
       ;

```

The above expression is read as:
<ul>
    <li>An expression could be just a number, or</li>
    <li>An expression is two expressions separated by '+' token, or</li>
    <li>An expression is two expressions separated by '-' token, or</li>
    <li>An expression is two expressions separated by '*' token, or</li>
    <li>An expression is two expressions separated by '/' token</li>
    <li>A number is always a T_INTLIT token</li>
</ul>


<h2>Recursive Descent Parsing</h2>

Given that the grammar for our language is recursive, let's try to parse it recursively. What we can do is to read in a token, the look ahead to the next token. Based on what the next token is, we can then decide what path we need to take to parse the input.

In out case, the first token in any expression will be a number and this may be followed by maths operator. After that there may only be a single number, or there may be the start of a whole new expression.

Pseudo-code for a recursive code looks something this:
```
function express(){

    Scan and check the first token is a number. Error if it's not 
    Get the next token
    If we have reached the end of the input, return, i.e. base case

    Otherwise, call expression()
}
```
Let's run this function on input 2+3-5 T_EOF where T_EOF is a token that reflects the end of the input. I will number each call to expression().

```
    expression0:
        Scan in the 2, it's a number
        Get next token, +, which isn't T_EOF
        Call expression()

        expression1:
            Scan in the 3, it's a number
            Get next token, -, which isn't T_EOF
            Call expression()

                expression2:
                    Scan in the 5, it's a number
                    Get next token, T_EOF, so return from expression2
            return from expression1
        return from expression0
```

Yes, the function was able to recursively parse the input `2 + 3 - 5 T_EOF`

Of course, we haven't done anything with the input but that's it the parser only parses the input and warn about syntax errors.

In short Parser is just syntax analysis.

Semantic Analysis is someone else's job.


<h2>Abstract Syntax Trees</h2>